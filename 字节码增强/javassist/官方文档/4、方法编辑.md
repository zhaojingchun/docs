

# 自省和定制

CtClass提供了内省的方法。Javassist的内省功能与Java反射API的内省功能兼容。CtClass提供了getName()、getSuperclass()、getMethods()等等。CtClass还提供了修改类定义的方法。它允许添加一个新的字段、构造函数和方法。检测方法体也是可能的。

方法由CtMethod对象表示。CtMethod提供了几个方法来修改方法的定义。注意，如果一个方法是从一个超类继承来的，那么表示继承方法的同一个CtMethod对象就表示在那个超类中声明的方法。一个CtMethod对象对应于每个方法声明。

例如，如果类Point声明了move()方法以及Point的一个子类ColorPoint不覆盖move()，那么在Point中声明并在ColorPoint中继承的两个move()方法将由相同的CtMethod对象表示。如果这个CtMethod对象所表示的方法定义被修改，这个修改将反映在这两个方法上。如果你只想修改ColorPoint中的move()方法，你首先必须向ColorPoint添加一个表示Point中的move()的CtMethod对象的副本。CtMethod对象的副本可以通过CtNewMethod.copy()获得。

Javassist不允许删除方法或字段，但允许更改名称。因此，如果一个方法不再需要，它应该通过调用在CtMethod中声明的setName()和setModifiers()来重命名并更改为私有方法。
Javassist也不允许向现有方法添加额外的参数。而不是这样做，接收额外参数和其他参数的新方法应该添加到同一个类中。例如，如果你想给一个方法添加一个额外的int参数newZ:

```java
void move(int newX, int newY) {x = newX;y = newY;}
```

在Point类中，那么你应该添加以下方法到Point类中:

```java
void move(int newX, int newY, int newZ) {
    // 做你想要的newZ。
    move(newX, newY);
}
```

Javassist还提供了直接编辑原始类文件的低级API。例如，CtClass中的getClassFile()返回一个ClassFile对象，表示一个原始的类文件。CtMethod中的getMethodInfo()返回一个MethodInfo对象，表示包含在类文件中的method_info结构。低级API使用Java虚拟机规范中的词汇表。用户必须具有关于类文件和字节码的知识。要了解更多细节，用户应该查看 [`javassist.bytecode` package](http://www.javassist.org/tutorial/tutorial3.html#intro).。

只有在使用了以$开头的一些特殊标识符时，Javassist修改的类文件才需要Javassist .runtime包来提供运行时支持。下面将描述这些特殊标识符。在没有这些特殊标识符的情况下修改的类文件在运行时不需要Javassist .runtime包或任何其他Javassist包。要了解更多细节，请参阅javassist.runtime包的API文档。

### 4.1在方法体的开头/结尾插入源文本

CtMethod和CtConstructor提供方法insertBefore()、insertAfter()和addCatch()。它们用于将代码片段插入现有方法的主体中。用户可以用Java编写的源文本指定这些代码片段。Javassist包含一个用于处理源文本的简单Java编译器。它接收用Java编写的源文本并将其编译为Java字节码，后者将内联到方法体中。

也可以在由行号指定的位置插入代码片段(如果行号表包含在类文件中)。CtMethod和CtConstructor中的insertAt()接受源文本和原始类定义的源文件中的行号。它编译源文本并在行号处插入编译后的代码。

方法insertBefore()、insertAfter()、addCatch()和insertAt()接收一个表示语句或块的String对象。语句是单个控制结构，如if和while或以分号(;)结尾的表达式。块是一组用大括号{}括起来的语句。因此，下面的每一行都是有效的语句或块的例子:

```java
System.out.println("Hello");
{ System.out.println("Hello"); }
if (i < 0) { i = -i; }
```

语句和块可以引用字段和方法。如果该方法是用-g选项编译的(以便在类文件中包含局部变量属性)，则它们还可以引用将其插入的方法的参数。否则，他们必须通过特殊变量$0，$1，$2，…访问方法参数。下面描述。不允许访问方法中声明的局部变量，但允许在块中声明新的局部变量。但是，insertAt()允许语句和块访问局部变量，前提是这些变量在指定的行号上可用，并且目标方法使用-g选项编译。
传递给方法insertBefore()、insertAfter()、addCatch()和insertAt()的String对象由Javassist中包含的编译器编译。由于编译器支持语言扩展，以$开头的几个标识符有特殊的含义:

$0， $1， $2，   …This和实际参数
                             $args参数数组。$args的类型为Object[]。
$$                        所有实际参数。
                             例如，m($$)等价于m($1，$2，…)

$cflow(…)            cflow变量
$r                         结果类型。它在强制转换表达式中使用。
$w                        包装器类型。它在强制转换表达式中使用。
$_                         结果值
$sig                      表示形式参数类型的java.lang.Class对象的数组。
$type                   一个java.lang.Class对象，表示正式的结果类型。
$class                 一个java.lang.Class对象，表示当前编辑的类。

#### $0, $1, $2, ...

传递给目标方法的参数可以通过$1，$2，…而不是原来的参数名。$1表示第一个参数，$2表示第二个参数，依此类推。这些变量的类型与参数类型相同。$0等价于this。如果方法是静态的，则$0不可用。

这些变量的使用如下。假设一个类Point:

```java
class Point {
    int x, y;
    void move(int dx, int dy) { x += dx; y += dy; }
}
```

要在调用move()方法时输出dx和dy的值，请执行以下程序:

```java
ClassPool pool = ClassPool.getDefault();
CtClass cc = pool.get("Point");
CtMethod m = cc.getDeclaredMethod("move");
m.insertBefore("{ System.out.println($1); System.out.println($2); }");
cc.writeFile();
```

注意，传递给insertBefore()的源文本被大括号{}所包围。insertBefore()只接受单个语句或用大括号括起来的块。

修改后的Point类的定义如下:

```java
class Point {
    int x, y;
    void move(int dx, int dy) {
        { System.out.println(dx); System.out.println(dy); }
        x += dx; y += dy;
    }
}
```

$1和$2分别替换为dx和dy。

$1，$2，$3……是可更新的。如果将一个新值赋给其中一个变量，那么由该变量表示的参数的值也将被更新。

#### $args

变量$args表示一个包含所有参数的数组。该变量的类型是Object类的数组。如果参数类型是基本类型(如int)，则将参数值转换为包装器对象(如java.lang.Integer)以存储在$args中。因此，$args[0]等价于$1，除非第一个参数的类型是基本类型。注意$args[0]不等于$0;$0代表this。

如果将Object数组赋值给$args，则将该数组的每个元素赋值给每个参数。如果参数类型是基元类型，则对应元素的类型必须是包装器类型。在将值分配给参数之前，将其从包装器类型转换为原始类型。

#### $$

变量$$是用逗号分隔的所有参数列表的缩写。例如，如果方法move()的参数个数为3，则

```java
move($$)
```

等价于:

```java
move($1, $2, $3)
```

如果move()不接受任何参数，那么move($$)等价于move()。

$$可以与另一种方法一起使用。如果你写一个表达式:

```java
exMove($$, context)
```

那么这个表达式等价于:

```java
exMove($1, $2, $3, context)
```

请注意，$$支持关于参数数量的方法调用的通用表示法。它通常与后面显示的$proceed一起使用。

#### $cflow

$cflow表示“控制流”。这个只读变量返回对特定方法的递归调用的深度。

假设下面所示的方法是由一个CtMethod对象cm表示的:

```java
int fact(int n) {
    if (n <= 1)
        return n;
    else
        return n * fact(n - 1);
}
```

要使用$cflow，首先声明$cflow用于监视对方法fact()的调用:

```java
CtMethod cm = ...;
cm.useCflow("fact");
```

useCflow()的参数是声明的$cflow变量的标识符。任何有效的Java名称都可以用作标识符。因为标识符也可以包含。(点)，例如“my.Test.Fact”是一个有效的标识符。

然后，$cflow(fact)表示cm指定的方法的递归调用的深度。当方法第一次被调用时，$cflow(fact)的值是0(零)，而当方法在方法内递归调用时，它是1。例如,

```java
cm.insertBefore("if ($cflow(fact) == 0)"
              + "    System.out.println(\"fact \" + $1);");
```

转换方法fact()，以便它显示参数。因为$cflow(fact)的值是被检查的，所以如果在fact()中递归调用方法fact()，它不会显示参数。

$cflow的值是当前线程的当前最顶层堆栈帧下与指定方法cm关联的堆栈帧数。$cflow也可以在不同于指定方法cm的方法中访问。

#### $r

$r表示方法的结果类型(返回类型)。它必须在强制转换表达式中用作强制转换类型。例如，这是一个典型的用法:

```java
Object result = ... ;
$_ = ($r)result;
```

如果结果类型是一个基本类型，那么($r)遵循特殊的语义。首先，如果强制转换表达式的操作数类型是基本类型，($r)将作为结果类型的普通强制转换操作符工作。另一方面，如果操作数类型是包装器类型，($r)将包装器类型转换为结果类型。例如，如果结果类型是int，那么($r)将从java.lang.Integer转换为int

如果结果类型为void，则($r)不转换类型;它什么都不做。但是，如果操作数是对void方法的调用，则($r)结果为null。例如，如果结果类型为void且foo()是一个void方法，则

```java
$_ = ($r)foo();
```

是一个有效的陈述。

强制转换操作符($r)在返回语句中也很有用。即使结果类型为void，下面的return语句也是有效的:

```java
return ($r)result;
```

这里，result是某个局部变量。由于指定了($r)，结果值将被丢弃。这个return语句被认为是没有结果值的return语句的等价部分:

```java
return;
```

#### $w

$w表示包装器类型。它必须在强制转换表达式中用作强制转换类型。($w)将原始类型转换为相应的包装类型。下面的代码是一个示例:

```java
Integer i = ($w)5;
```

所选的包装器类型取决于下面表达式的类型($w)。如果表达式的类型是double，则包装器类型是java.lang.Double。

如果后面的表达式($w)的类型不是基元类型，则($w)不执行任何操作。

#### $_

CtMethod中的insertAfter()和CtConstructor将编译后的代码插入到方法的末尾。在给insertAfter()的语句中，不仅上面显示的变量如$0，$1，…但是$_也是可用的。

变量$_ 表示方法的结果值。该变量的类型是方法的结果类型(返回类型)的类型。如果结果类型为void，则$_ 的类型为Object，且$_的值为null。

尽管由insertAfter()插入的编译后的代码在控件通常从方法返回之前执行，但它也可以在方法抛出异常时执行。要在抛出异常时执行它，第二个参数asFinally To insertAfter()必须为真。

如果抛出异常，则由insertAfter()插入的已编译代码将作为finally子句执行。$_的值在编译后的代码中为0或null。在已编译代码的执行结束后，最初抛出的异常将重新抛出给调用者。注意$_的值永远不会被抛出给调用者;它被丢弃了。

#### $sig

$sig的值是java.lang.Class对象的数组，这些对象按声明顺序表示形式参数类型。

#### $type

$type的值是一个java.lang.Class对象，表示结果值的正式类型。如果这是一个构造函数，那么这个变量将引用Void.class。

#### $class

$class的值是一个java.lang.Class对象，表示在其中声明编辑方法的类。这表示$0的类型。

#### addCatch()

addCatch()将代码片段插入方法体中，以便在方法体抛出异常并将控件返回给调用者时执行代码片段。在表示插入代码片段的源文本中，使用特殊变量$e引用异常值。

例如，这个程序:

```java
CtMethod m = ...;
CtClass etype = ClassPool.getDefault().get("java.io.IOException");
m.addCatch("{ System.out.println($e); throw $e; }", etype);
```

将m表示的方法主体转换为如下所示:

```java
try {
    the original method body
}
catch (java.io.IOException e) {
    System.out.println(e);
    throw e;
}
```

注意，插入的代码片段必须以throw或return语句结束。

### 4.2修改方法体

CtMethod和CtConstructor提供了setBody()来替换整个方法体。它们将给定的源文本编译为Java字节码并将其替换为原始方法体。如果给定的源文本为null，则被替换的正文只包含一个return语句，该语句返回0或null，除非结果类型为void。

在给setBody()的源文本中，以$开头的标识符具有特殊含义

$0，$1，$2…                    This和实际参数
$args                                  参数数组。$args的类型为Object[]。
$$                                       所有实际参数。
$cflow(…)                          cflow变量
$r                                        结果类型。它在强制转换表达式中使用。
$w                                      包装器类型。它在强制转换表达式中使用。
$sig                                     表示形式参数类型的java.lang.Class对象的数组。
$type                                  java.lang.Class对象，表示正式的结果类型。
$class                                 一个java.lang.Class对象，表示声明方法的类
                                            当前编辑(类型$0)。

注意$_不可用。

#### 将源文本替换为现有表达式

Javassist只允许修改方法体中包含的表达式。javassist.expr.ExprEditor是一个用于替换方法体中的表达式的类。用户可以定义ExprEditor的子类来指定如何修改表达式。

要运行ExprEditor对象，用户必须在CtMethod或CtClass中调用instrument()。例如,

```java
CtMethod cm = ... ;
cm.instrument(
    new ExprEditor() {
        public void edit(MethodCall m)
                      throws CannotCompileException
        {
            if (m.getClassName().equals("Point")
                          && m.getMethodName().equals("move"))
                m.replace("{ $1 = 0; $_ = $proceed($$); }");
        }
    });
```

搜索由cm表示的方法体，并用下面block替换类Point中对move()的所有调用:

```java
{ $1 = 0; $_ = $proceed($$); }
```

所以move()的第一个参数总是0。注意，被替换的代码不是表达式，而是语句或块。它不能是或包含try-catch语句。

方法instrument()搜索方法主体。如果它找到一个表达式，比如方法调用、字段访问和对象创建，那么它就对给定的ExprEditor对象调用edit()。edit()的参数是一个表示找到的表达式的对象。edit()方法可以通过该对象检查和替换表达式。

在参数上调用replace()来编辑()，用给定的语句或块替换表达式。如果给定的块是一个空块，也就是说，如果执行replace("{}")，则该表达式将从方法体中删除。如果你想在表达式之前或之后插入一个语句(或一个块)，应该传递一个像下面这样的块来replace():

```java
{ before-statements;
  $_ = $proceed($$);
  after-statements; }
```

无论表达式是方法调用、字段访问、对象创建还是其他。第二句可以是:

```java
$_ = $proceed();
```

如果表达式是读访问，或

```java
$proceed($$);
```

如果表达式是写访问。

如果instrument()搜索的方法是用-g选项编译的(类文件包含一个局部变量属性)，那么目标表达式中可用的局部变量在传递给replace()的源文本中也可用。

#### javassist.expr.MethodCall

MethodCall对象表示一个方法调用。MethodCall中的方法replace()用语句或块代替方法调用。它接收表示替换语句或块的源文本，其中以$开头的标识符具有特殊含义，就像传递给insertBefore()的源文本一样。

$0                                 方法调用的目标对象。
                                     This与This不相等，后者表示调用者端这个对象。
                                     如果方法是静态的，$0为null。

$ 1、$ 2,……               方法调用的参数。
$_                                 方法调用的结果值。

$r                                 方法调用的结果类型。
$class                          一个java.lang.Class对象，表示声明方法的类。
$sig                             表示形式参数类型的java.lang.Class对象数组。
$type                           java.lang.Class对象，表示正式的结果类型。
$procceed                  表达式中最初调用的方法的名称。

这里的方法调用是指MethodCall对象所表示的方法调用。

其他标识符，如$w、$args和$$也可用。

除非方法调用的结果类型是void，否则必须在源文本中给$_赋值，并且$_的类型是结果类型。如果结果类型为void，则$_ 的类型为Object，赋给$_ 的值将被忽略。

$proceed不是String值，而是特殊的语法。它必须后跟一个由圆括号()包围的参数列表。

#### javassist.expr.ConstructorCall

......

http://www.javassist.org/tutorial/tutorial2.html#intro

### 添加一个新方法或字段

#### 添加一个方法

Javassist允许用户从头创建一个新方法和构造函数。CtNewMethod和CtNewConstructor提供了几个工厂方法，它们是用于创建CtMethod或CtConstructor对象的静态方法。特别是，make()从给定的源文本创建一个CtMethod或CtConstructor对象。

例如，这个程序:

```java
CtClass point = ClassPool.getDefault().get("Point");
CtMethod m = CtNewMethod.make(
                 "public int xmove(int dx) { x += dx; }",
                 point);
point.addMethod(m);
```

将一个公共方法xmove()添加到类Point。在本例中，x是Point类中的int字段。

传递给make()的源文本可以包含以$开头的标识符，但setBody()中的$_除外。如果目标对象和目标方法名也被指定为make()，则还可以包含$proceed。例如,

```java
CtClass point = ClassPool.getDefault().get("Point");
CtMethod m = CtNewMethod.make(
                 "public int ymove(int dy) { $proceed(0, dy); }",
                 point, "this", "move");
```

这个程序创建了一个方法ymove()，如下所示:

```java
public int ymove(int dy) { this.move(0, dy); }
```

注意$proceed已经被this.move替换。

Javassist提供了另一种添加新方法的方法。你可以先创建一个抽象方法，然后给它一个方法体

```java
CtClass cc = ... ;
CtMethod m = new CtMethod(CtClass.intType, "move",
                          new CtClass[] { CtClass.intType }, cc);
cc.addMethod(m);
m.setBody("{ x += $1; }");
cc.setModifiers(cc.getModifiers() & ~Modifier.ABSTRACT);
```

由于Javassist在类中添加抽象方法时会使类抽象，因此在调用setBody()之后必须显式地将类更改为非抽象类。

#### 相互递归方法

























































